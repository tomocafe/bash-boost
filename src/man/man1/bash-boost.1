.\" Automatically generated by Pandoc 2.19.2
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "BASH-BOOST" "1" "August 11, 2024" "" ""
.hy
.SH Package cli/arg
.PP
Routines for parsing command line arguments
.PP
\f[B]Example:\f[R]
.IP
.nf
\f[C]
bb_setprog \[dq]myprogram\[dq]
bb_addopt f:foo \[dq]Number of foos (default: 2)\[dq] 2
bb_addflag b:bar \[dq]Bar flag\[dq]
bb_setpositional \[dq]THINGS\[dq] \[dq]Things to process\[dq]
bb_parseargs \[dq]$\[at]\[dq]
set -- \[dq]${BB_POSARGS[\[at]]}\[dq] # $\[at] now only contains the positional arguments
bb_checkopt bar && echo \[dq]You gave the bar flag!\[dq]
bb_getopt -v fooval foo
[[ $fooval -gt 0 ]] || bb_errusage \[dq]foo val must be greater than 0\[dq]
echo \[dq]You set foo to $fooval\[dq]
for arg in \[dq]$\[at]\[dq]; do
  echo \[dq]You have item $arg\[dq]
done
\f[R]
.fi
.PP
\f[B]Example:\f[R]
.IP
.nf
\f[C]
bb_setprog \[dq]copy\[dq]
bb_addflag \[dq]f:force\[dq] \[dq]force overwrite destination\[dq]
bb_addarg \[dq]src\[dq] \[dq]source file/directory\[dq]
bb_addarg \[dq]dst\[dq] \[dq]destination path\[dq]
bb_parseargs \[dq]$\[at]\[dq]
bb_getopt -v src src || bb_errusage \[dq]missing required src argument\[dq]
bb_getopt -v dst fst || bb_errusage \[dq]missing required dst argument\[dq]
[[ -e \[dq]$dst\[dq] && ! bb_checkopt force ]] && bb_fatal \[dq]$dst exists\[dq]
cp \[dq]$src\[dq] \[dq]$dst\[dq]
\f[R]
.fi
.SS \f[V]bb_addopt [SHORTNAME:]LONGNAME [DESCRIPTION] [DEFAULT]\f[R]
.PP
Adds a command line option to be parsed
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]SHORTNAME\f[R]: optional single character, e.g.\ \[lq]f\[rq] for an
-f FOO option
.IP \[bu] 2
\f[V]LONGNAME\f[R]: required long name, e.g.\ \[lq]foo\[rq] for a
\[en]foo FOO option
.IP \[bu] 2
\f[V]DESCRIPTION\f[R]: description of the option used in help
.IP \[bu] 2
\f[V]DEFAULT\f[R]: the default value of the option if not given in the
command line
.PP
\f[B]Notes:\f[R]
.PP
-h and \[en]help are reserved for automatically-generated command usage
and help
.SS \f[V]bb_addarg NAME DESCRIPTION [DEFAULT]\f[R]
.PP
Adds a named argument
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]NAME\f[R]: unique, one-word name of the argument
.IP \[bu] 2
\f[V]DESCRIPTION\f[R]: description of the argument used in help
.IP \[bu] 2
\f[V]DEFAULT\f[R]: default value if not given in the command line
.SS \f[V]bb_addflag [SHORTNAME:]LONGNAME [DESCRIPTION]\f[R]
.PP
Adds a command line flag to be parsed
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]SHORTNAME\f[R]: optional single character, e.g.\ \[lq]f\[rq] for an
-f flag
.IP \[bu] 2
\f[V]LONGNAME\f[R]: required long name, e.g.\ \[lq]foo\[rq] for a
\[en]foo flag
.IP \[bu] 2
\f[V]DESCRIPTION\f[R]: description of the option used in help
.PP
\f[B]Notes:\f[R]
.PP
-h and \[en]help are reserved for automatically-generated command usage
and help
.SS \f[V]bb_argusage\f[R]
.PP
Print the command line usage string
.SS \f[V]bb_arghelp\f[R]
.PP
Print the command line help
.PP
\f[B]Notes:\f[R]
.PP
Includes the usage string and a list of flags and options with their
descriptions.
.SS \f[V]bb_errusage MESSAGE [RETURNVAL]\f[R]
.PP
Issues an error message, prints the command usage, and exits the shell
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]MESSAGE\f[R]: error message to be printed
.IP \[bu] 2
\f[V]RETURNVAL\f[R]: return code to exit with (defaults to 1)
.SS \f[V]bb_isflag LONGNAME\f[R]
.PP
Check if LONGNAME is a registered flag (not an option)
.PP
\f[B]Returns:\f[R] 0 if LONGNAME is a flag, 1 otherwise (i.e.\ it is an
option)
.SS \f[V]bb_setprog [PROGNAME]\f[R]
.PP
Sets the name of the program for printing usage and help
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]PROGNAME\f[R]: name of the program (defaults to current script
name)
.SS \f[V]bb_setpositional NAME DESCRIPTION\f[R]
.PP
Sets the name and description of the positional arguments
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]NAME\f[R]: one-word name of the positional arguments
(auto-capitalized)
.IP \[bu] 2
\f[V]DESCRIPTION\f[R]: description of the positionals used in help
.SS \f[V]bb_parseargs ARGS\f[R]
.PP
Parses command line arguments after registering valid flags and options
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]ARGS\f[R]: the list of command line arguments, usually
\[lq]$\[at]\[rq]
.PP
\f[B]Notes:\f[R]
.IP \[bu] 2
Check flags with \f[V]bb_checkopt LONGNAME\f[R]
.IP \[bu] 2
Get option setting values or named arguments with
\f[V]bb_getopt LONGNAME\f[R]
.IP \[bu] 2
Get positional arguments with \f[V]${BB_POSARGS[\[at]]}\f[R] array
.IP \[bu] 2
If the last argument is a single dash (-), read remaining arguments from
stdin
.SS \f[V]bb_processargs\f[R]
.PP
Parses arguments in $\[at] and modifies it in-place to only hold
positional arguments
.PP
\f[B]Notes:\f[R]
.PP
To use this in a script, you must do \f[V]shopt -s expand_aliases\f[R]
.SS \f[V]bb_getopt [-v VAR] LONGNAME\f[R]
.PP
Gets the value of option or argument by name
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]LONGNAME\f[R]: long name of the option (or named argument)
.PP
\f[B]Returns:\f[R] true if the result is nonempty
.SS \f[V]bb_checkopt LONGNAME\f[R]
.PP
Returns the value of flag named LONGNAME
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LONGNAME\f[R]: long name of the flag
.PP
\f[B]Returns:\f[R] the flag value, either true or false
.PP
\f[B]Notes:\f[R]
.PP
Undefined if used on an opt instead of a flag
.SS \f[V]bb_argclear\f[R]
.PP
Clears all registered argument parsing settings
.PP
\f[B]Notes:\f[R]
.PP
Only one \[lq]command\[rq] can be registered for parsing at once so this
can be used to clear the state of a previous command and start a new one
.SH Package cli/color
.PP
Routines for printing text in color using ANSI escape codes
.SS \f[V]bb_colorize COLORSTR TEXT\f[R]
.PP
Prints the given text in color if outputting to a terminal
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]COLORSTR\f[R]: FGCOLOR[\f[I]on\f[R][BGCOLOR]] (e.g.\ red,
bright_red, white_on_blue)
.IP \[bu] 2
\f[V]TEXT\f[R]: text to be printed in color
.PP
\f[B]Returns:\f[R] 0 if text was printed in color, 1 otherwise
.PP
\f[B]Notes:\f[R]
.PP
Supported colors: - black - red - green - yellow - blue - magenta - cyan
- bright_gray (dark_white) - gray (bright_black) - bright_red -
bright_green - bright_yellow - bright_blue - bright_magenta -
bright_cyan - white (bright_white)
.PP
This does not print a new line at the end of TEXT
.SS \f[V]bb_rawcolor COLORSTR TEXT\f[R]
.PP
Like colorize but always uses prints in color
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]COLORSTR\f[R]: FGCOLOR[\f[I]on\f[R][BGCOLOR]] (e.g.\ red,
bright_red, white_on_blue)
.IP \[bu] 2
\f[V]TEXT\f[R]: text to be printed in color
.PP
\f[B]Notes:\f[R]
.PP
Use this instead of colorize if you need to still print in color even if
not connected to a terminal, e.g.\ when saving the output to a variable.
See colorize for supported colors
.SS \f[V]bb_colorstrip TEXT\f[R]
.PP
Strips ANSI color codes from text colorized by colorize (or rawcolor)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]TEXT\f[R]: text possibly with color escape codes to be removed
.PP
\f[B]Notes:\f[R]
.PP
This is only guaranteed to work on text generated by colorize and
variants, not for any generic string with ANSI escape codes.
.SH Package cli/input
.PP
Routines for handling user input
.SS \f[V]bb_getinput VAR PROMPT\f[R]
.PP
Prompts for input and saves the response to VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store response into (do not include $)
.IP \[bu] 2
\f[V]PROMPT\f[R]: text displayed to the user
.SS \f[V]bb_yn PROMPT\f[R]
.PP
Prompts user to confirm an action by pressing Y
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]PROMPT\f[R]: text displayed to the user
.PP
\f[B]Returns:\f[R] 0 if yes, 1 otherwise
.PP
\f[B]Notes:\f[R]
.PP
If you want the user to type \[lq]yes\[rq], use getinput and check their
response
.SS \f[V]bb_pause PROMPT\f[R]
.PP
Prompts user to press a key to continue
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]PROMPT\f[R]: text displayed to the user Default: Press any key to
continue
.SH Package cli/msg
.PP
Messaging routines
.SS \f[V]bb_info MESSAGE\f[R]
.PP
Prints an informational message to stderr
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]MESSAGE\f[R]: message to be printed
.SS \f[V]bb_warn MESSAGE\f[R]
.PP
Prints a warning message to stderr
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]MESSAGE\f[R]: message to be printed
.SS \f[V]bb_error MESSAGE\f[R]
.PP
Prints an error message to stderr
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]MESSAGE\f[R]: message to be printed
.SS \f[V]bb_fatal MESSAGE [RETURNCODE]\f[R]
.PP
Prints an error message to stderr and then exits the shell
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]MESSAGE\f[R]: message to be printed
.IP \[bu] 2
\f[V]RETURNCODE\f[R]: return code to exit with (defaults to 1)
.SS \f[V]bb_expect VAL1 VAL2 [MESSAGE] [RETURNCODE]\f[R]
.PP
Issues a fatal error if two given values are not equal
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAL1\f[R]: value to check
.IP \[bu] 2
\f[V]VAL2\f[R]: value to check against (golden answer)
.IP \[bu] 2
\f[V]MESSAGE\f[R]: optional prefix to the error message
.IP \[bu] 2
\f[V]RETURNCODE\f[R]: return code to exit with (defaults to 1)
.SS \f[V]bb_expectsubstr TEXT PATTERN [MESSAGE] [RETURNCODE]\f[R]
.PP
Issues a fatal error if a given substring is not found in some given
text
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]TEXT\f[R]: text to check
.IP \[bu] 2
\f[V]PATTERN\f[R]: substring to be found
.IP \[bu] 2
\f[V]MESSAGE\f[R]: optional prefix to the error message
.IP \[bu] 2
\f[V]RETURNCODE\f[R]: return code to exit with (defaults to 1)
.SS \f[V]bb_expectre TEXT PATTERN [MESSAGE] [RETURNCODE]\f[R]
.PP
Issues a fatal error if text does not match the given regular expression
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]TEXT\f[R]: text to check
.IP \[bu] 2
\f[V]PATTERN\f[R]: regular expression
.IP \[bu] 2
\f[V]MESSAGE\f[R]: optional prefix to the error message
.IP \[bu] 2
\f[V]RETURNCODE\f[R]: return code to exit with (defaults to 1)
.SS \f[V]bb_loglevel [LEVEL]\f[R]
.PP
Sets the current log level
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LEVEL\f[R]: integer representing the current log verbosity level
(default: 0)
.SS \f[V]bb_setloglevelname LEVEL NAME\f[R]
.PP
Assigns a name to the given log level
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LEVEL\f[R]: integer representing the current log verbosity level
.IP \[bu] 2
\f[V]NAME\f[R]: name to be assigned
.SS \f[V]bb_log LEVEL MESSAGE\f[R]
.PP
Issues a message at a certain log level
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LEVEL\f[R]: minimum logging level required to print the message
.IP \[bu] 2
\f[V]MESSAGE\f[R]: message to be printed
.PP
\f[B]Notes:\f[R]
.PP
Set BB_LOG_TIMEFMT to a valid time format string to override the default
.SH Package cli/progress
.PP
Text-based progress bar and checkpoint pass/fail status line generator
.PP
\f[B]Example:\f[R]
.IP
.nf
\f[C]
ping -c 1 8.8.8.8 &>/dev/null; bb_checkpoint \[dq]Pinging DNS\[dq]
for pct in {0..100}; do sleep 0.1s; bb_progressbar $pct \[dq]Downloading\[dq]; done; echo
\f[R]
.fi
.SS \f[V]bb_progressbar VALUE TEXT\f[R]
.PP
Prints/updates a progress bar
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VALUE\f[R]: integer from 0 to 100; 100 meaning complete
.IP \[bu] 2
\f[V]TEXT\f[R]: optional text to be displayed
.PP
\f[B]Notes:\f[R]
.PP
Customize the start, end, and fill characters by setting environment
variables BB_PROGRESS_START, BB_PROGRESS_END, and BB_PROGRESS_FILL.
By default these are set to [, ], and .
.SS \f[V]bb_checkpoint TEXT [RESULT]\f[R]
.PP
Prints a status line with pass/fail result based on RESULT
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]TEXT\f[R]: text to be displayed
.IP \[bu] 2
\f[V]RESULT\f[R]: 0 for pass, nonzero for fail; if not given, infers
from $?
.PP
\f[B]Notes:\f[R]
.PP
Customize the fill character and pass/fail text by setting environment
variables BB_CHECKPOINT_FILL, BB_CHECKPOINT_PASS, and
BB_CHECKPOINT_FAIL.
By default these are set to space, OK, and FAIL.
.SH Package core
.PP
Core routines
.SS \f[V]bb_load PKG ...\f[R]
.PP
Loads a module or package
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]PKG\f[R]: either a package (e.g.\ cli/arg) or a whole module
(e.g.\ cli)
.PP
\f[B]Notes:\f[R]
.PP
Each package only loads once; if you happen to load one twice, the
second time has no effect
.SS \f[V]bb_isloaded PKG\f[R]
.PP
Checks if a package is loaded already
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]PKG\f[R]: package name in internal format, e.g.\ bb_cli_arg
.PP
\f[B]Returns:\f[R] 0 if loaded, 1 otherwise
.SS \f[V]bb_debug TEXT\f[R]
.PP
Log text when debugging is enabled
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]TEXT\f[R]: message to be logged in debug mode
.PP
\f[B]Notes:\f[R]
.PP
Set environment variable BB_DEBUG to enable debug mode
.SS \f[V]bb_issourced\f[R]
.PP
Check if the script is being sourced
.PP
\f[B]Returns:\f[R] 0 if sourced, 1 otherwise
.SS \f[V]bb_stacktrace\f[R]
.PP
Print a stack trace to stderr
.SS \f[V]bb_cleanup\f[R]
.PP
Clears all functions and variables defined by bash-boost
.SH Package interactive/bookmark
.PP
Directory bookmarking system
.SS \f[V]bb_addbookmark [KEY] [DIR]\f[R]
.PP
Adds a bookmark to the directory for quick recall
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]KEY\f[R]: single character to assign bookmark to
.IP \[bu] 2
\f[V]DIR\f[R]: directory to bookmark; defaults to current directory
.PP
\f[B]Notes:\f[R]
.PP
If DIR is already bookmarked, this will clear the previously associated
key If KEY is already used, this will overwrite the orevious assignment
.SS \f[V]bb_delbookmark [KEY]\f[R]
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]KEY\f[R]: bookmark key to delete; prompts if unspecified
.PP
\f[B]Notes:\f[R]
.PP
Useful as a keyboard shortcut, e.g., Ctrl+X-B
.SS \f[V]bb_bookmark [KEY] [DIR]\f[R]
.PP
Go to the directory bookmarked by KEY if it exists, otherwise create
bookmark
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]KEY\f[R]: single character to assign bookmark to; prompts if
unspecified
.IP \[bu] 2
\f[V]DIR\f[R]: directory to bookmark; defaults to current directory
.PP
\f[B]Notes:\f[R]
.PP
If DIR is already bookmarked, this will clear the previously associated
key.
If KEY is already used but you wish to overwrite it, use bb_addbookmark
or use bb_delbookmark KEY first Useful as a keyboard shortcut, e.g.,
Ctrl+B
.SS \f[V]bb_showbookmark [KEY]\f[R]
.PP
Shows the current mapping of KEY, or all keys if KEY is unspecified
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]KEY\f[R]: bookmark key to show
.SS \f[V]bb_getbookmark [DIR]\f[R]
.PP
Prints bookmark key assigned to the given DIR if such a bookmark exists
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]DIR\f[R]: directory to get assigned bookmark key of; defaults to
current directory
.SS \f[V]bb_loadbookmark FILE\f[R]
.PP
Loads bookmark assignments from FILE
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]FILE\f[R]: a file containing bookmark assignments
.PP
\f[B]Notes:\f[R]
.PP
FILE should be formatted with an assignment on each line, with each
assignment being a letter followed by a path, separated by space
.SH Package interactive/cmd
.PP
Miscellaneous interactive commands
.SS \f[V]bb_mcd DIR\f[R]
.PP
Make director(ies) and change directory to the last one
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]DIR\f[R]: usually a single directory to be made, but all arguments
are passed to mkdir and the last argument is then passed to cd if mkdir
is successful
.SS \f[V]bb_up [DIR]\f[R]
.PP
Change directory up
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]DIR\f[R]: go to this directory, otherwise defaults to ..
if no DIR specified
.PP
\f[B]Notes:\f[R]
.PP
Most useful with the associated command completion.
After pressing TAB, the current working directory is populated, and with
each further TAB, a directory is removed, moving you up the directory
stack.
Once you see the upward directory you want to go to, hit ENTER
.SS \f[V]bb_forkterm [ARGS ...]\f[R]
.PP
Spawn a new terminal instance inheriting from this shell\[cq]s
environment
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]ARGS\f[R]: arguments to be appended to the terminal launch command
.PP
\f[B]Notes:\f[R]
.IP \[bu] 2
Uses the BB_TERMINAL or TERMINAL environment variable as the command to
launch the new terminal instance.
.IP \[bu] 2
Sets the BB_FORKDIR variable for the spawned shell to read.
In your shell init file, you can detect when this variable is set and
change to this directory, if desired.
.IP \[bu] 2
BB_TERMINAL can be a list with arguments, or a string which will be
tokenized by space.
If your arguments contain spaces, you will need to declare the variable
as a list.
.SH Package interactive/prompt
.PP
Routines for managing a dynamic shell prompt
.SS \f[V]bb_loadprompt\f[R]
.PP
Activates the registered dynamic prompt
.SS \f[V]bb_unloadprompt\f[R]
.PP
Deactivates the registered dynamic prompt
.PP
\f[B]Notes:\f[R]
.PP
This will restore the prompt to the state it was in when loadprompt was
called
.SS \f[V]bb_setpromptleft FUNCTION ...\f[R]
.PP
Sets the left prompt to the output of the list of given functions
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]FUNCTION\f[R]: a function whose stdout output will be added to the
prompt
.PP
\f[B]Notes:\f[R]
.PP
The prompt areas are as follows:
.IP
.nf
\f[C]
  +----------------------------------------+
  | left prompt               right prompt |
  | nextline prompt                        |
  +----------------------------------------+
\f[R]
.fi
.SS \f[V]bb_setpromptright FUNCTION ...\f[R]
.PP
Sets the right prompt to the output of the list of given functions
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]FUNCTION\f[R]: a function whose stdout output will be added to the
prompt
.SS \f[V]bb_setpromptnextline FUNCTION ...\f[R]
.PP
Sets the next line prompt to the output of the list of given functions
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]FUNCTION\f[R]: a function whose stdout output will be added to the
prompt
.SS \f[V]bb_setwintitle FUNCTION\f[R]
.PP
Sets the window title to the output of the list of given functions
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]FUNCTION\f[R]: a function whose stdout output will used as the
window title
.SS \f[V]bb_settabtitle FUNCTION\f[R]
.PP
Sets the tab title to the output of the list of given functions
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]FUNCTION\f[R]: a function whose stdout output will used as the tab
title
.PP
\f[B]Notes:\f[R]
.PP
Not all terminals support this
.SS \f[V]bb_promptcolor COLORSTR TEXT\f[R]
.PP
Prints text in color, for use specifically in prompts
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]COLORSTR\f[R]: valid color string, see bb_colorize
.IP \[bu] 2
\f[V]TEXT\f[R]: text to be printed in color
.PP
\f[B]Notes:\f[R]
.PP
This is like colorize but adds [ and ] around non-printing characters
which are needed specifically in prompts
.SH Package util/env
.PP
Routines for checking and setting environment variables
.SS \f[V]bb_checkset VAR\f[R]
.PP
Check if an environment variable is set or empty
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: name of the variable to check (don\[cq]t include $)
.PP
\f[B]Returns:\f[R] 1 if unset, 2 if set but empty, 0 otherwise
.SS \f[V]bb_iscmd COMMAND\f[R]
.PP
Check if COMMAND is a valid command
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]COMMAND\f[R]: name of command to check (e.g., ls)
.PP
\f[B]Notes:\f[R]
.PP
This could be an executable in your PATH, or a function or bash builtin
.SS \f[V]bb_inpath VAR ITEM ...\f[R]
.PP
Checks if items are in the colon-separated path variable VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[V]ITEM\f[R]: items to find in the path variable
.PP
\f[B]Returns:\f[R] 0 if all items are in the path, 1 otherwise
.SS \f[V]bb_prependpath VAR ITEM ...\f[R]
.PP
Prepends items to the colon-separated path variable VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[V]ITEM\f[R]: items to add to the path variable
.SS \f[V]bb_appendpath VAR ITEM ...\f[R]
.PP
Appends items to the colon-separated path variable VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[V]ITEM\f[R]: items to add to the path variable
.SS \f[V]bb_prependpathuniq VAR ITEM ...\f[R]
.PP
Prepends unique items to the colon-separated path variable VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[V]ITEM\f[R]: items to add to the path variable
.PP
\f[B]Notes:\f[R]
.PP
If an item is already in the path, it is not added twice
.SS \f[V]bb_appendpathuniq VAR ITEM ...\f[R]
.PP
Appends unique items to the colon-separated path variable VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[V]ITEM\f[R]: items to add to the path variable
.PP
\f[B]Notes:\f[R]
.PP
If an item is already in the path, it is not added twice
.SS \f[V]bb_removefrompath VAR ITEM ...\f[R]
.PP
Removes items from the colon-separated path variable VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[V]ITEM\f[R]: items to remove from the path variable
.PP
\f[B]Returns:\f[R] 0 if any item was removed, 1 otherwise
.SS \f[V]bb_swapinpath VAR ITEM1 ITEM2\f[R]
.PP
Swaps two items in a colon-separated path variable VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[V]ITEM1\f[R]: first item to swap
.IP \[bu] 2
\f[V]ITEM2\f[R]: second item to swap
.PP
\f[B]Returns:\f[R] 0 if swap is successful, 1 if either ITEM1 or ITEM2
was not in the path 2 if insufficient arguments were supplied (less than
3) 3 for internal error
.SS \f[V]bb_printpath VAR [SEP]\f[R]
.PP
Prints a path variable separated by SEP, one item per line
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[V]SEP\f[R]: separator character, defaults to :
.SH Package util/file
.PP
Routines for common file operations
.SS \f[V]bb_canonicalize [-v VAR] PATH\f[R]
.PP
Resolves .
and ..
in a given absolute path
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]PATH\f[R]: an absolute path
.PP
\f[B]Returns:\f[R] 1 if PATH is invalid, 0 otherwise
.SS \f[V]bb_abspath [-v VAR] TARGET [FROM]\f[R]
.PP
Returns the absolute path from a relative one
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]TARGET\f[R]: target relative path (can be file or directory)
.IP \[bu] 2
\f[V]FROM\f[R]: the absolute directory path from which the absolute path
is formed (Defaults to $PWD)
.SS \f[V]bb_relpath [-v VAR] TARGET [FROM]\f[R]
.PP
Returns the relative path from a directory to the target
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]TARGET\f[R]: target absolute path (can be file or directory)
.IP \[bu] 2
\f[V]FROM\f[R]: the absolute directory path from which the relative path
is formed (Defaults to $PWD)
.PP
\f[B]Returns:\f[R] 1 if either TARGET or FROM is invalid, 0 otherwise
.SS \f[V]bb_prettypath PATH\f[R]
.PP
Prints a pretty version of the path
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]PATH\f[R]: a path
.PP
\f[B]Notes:\f[R]
.PP
Replaces home directory with \[ti]
.SS \f[V]bb_countlines FILENAME ...\f[R]
.PP
Counts the number of lines in a list of files
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]FILENAME\f[R]: a valid filename
.PP
\f[B]Returns:\f[R] 1 if any of the filenames are invalid, 0 otherwise
.SS \f[V]bb_countmatches PATTERN FILENAME ...\f[R]
.PP
Counts the number of matching lines in a list of files
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]PATTERN\f[R]: a valid bash regular expression
.IP \[bu] 2
\f[V]FILENAME\f[R]: a valid filename
.PP
\f[B]Returns:\f[R] 1 if any of the filenames are invalid, 0 otherwise
.SS \f[V]bb_extpush EXT FILENAME ...\f[R]
.PP
Adds the file extension EXT to all given files
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]EXT\f[R]: the file extension
.IP \[bu] 2
\f[V]FILENAME\f[R]: a valid filename
.SS \f[V]bb_extpop FILENAME ...\f[R]
.PP
Removes the last file extension from the given files
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]FILENAME\f[R]: a valid filename
.SS \f[V]bb_hardcopy FILENAME ...\f[R]
.PP
Replaces symbolic links with deep copies
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]FILENAME\f[R]: a valid symbolic link
.SS \f[V]bb_scriptpath [-v VAR]\f[R]
.PP
Returns the unresolved directory name of the current script
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.SH Package util/kwargs
.PP
Routines for parsing keyword arg strings
.PP
\f[B]Example:\f[R]
.IP
.nf
\f[C]
talk() {
  bb_kwparse opts \[dq]$\[at]\[dq]
  set -- \[dq]${BB_OTHERARGS[\[at]]}\[dq] # $\[at] now only contains non-kwargs
  local verb=\[dq]${opts[verb]:-have}\[dq]
  local item
  for item in \[dq]$\[at]\[dq]; do
    echo \[dq]You $verb $item\[dq]
  done
}
talk eggs milk bread
talk verb=ate eggs milk bread
\f[R]
.fi
.SS \f[V]bb_kwparse MAP KEY=VAL ... ARGS ...\f[R]
.PP
Parses a list of KEY=VAL pairs and stores them into a dictionary
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]MAP\f[R]: name of an associative array to be created
.IP \[bu] 2
\f[V]KEY=VAL\f[R]: a key-value pair separated by =
.IP \[bu] 2
\f[V]ARGS\f[R]: other arguments not in KEY=VAL format are ignored
.PP
\f[B]Notes:\f[R]
.PP
Get non-keyword arguments with ${BB_OTHERARGS[\[at]]}
.SH Package util/list
.PP
Routines for common list operations
.SS \f[V]bb_join [-v VAR] SEP ITEM ...\f[R]
.PP
Joins the list of items into a string with the given separator
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]SEP\f[R]: separator
.IP \[bu] 2
\f[V]ITEM\f[R]: a list item
.SS \f[V]bb_split [-V LISTVAR] SEP STR\f[R]
.PP
Splits a string into a list based on a separator
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[V]SEP\f[R]: separator
.IP \[bu] 2
\f[V]STR\f[R]: string to split
.SS \f[V]bb_inlist TARGET LIST ...\f[R]
.PP
Checks if a target item exists in a given list
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]TARGET\f[R]: the search target
.IP \[bu] 2
\f[V]LIST\f[R]: a list item
.PP
\f[B]Returns:\f[R] 0 if found, 1 otherwise
.SS \f[V]bb_push LISTVAR ITEM ...\f[R]
.PP
Pushes an item to a list (stack)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: name of the list variable (do not include $)
.IP \[bu] 2
\f[V]ITEM\f[R]: item to push
.SS \f[V]bb_pop LISTVAR\f[R]
.PP
Pops an item from a list (stack)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: name of the list variable (do not include $)
.SS \f[V]bb_unshift LISTVAR ITEM ...\f[R]
.PP
Unshifts an item from a list (stack)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: name of the list variable (do not include $)
.IP \[bu] 2
\f[V]ITEM\f[R]: item to unshift
.SS \f[V]bb_shift LISTVAR\f[R]
.PP
Shifts an item from a list (stack)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: name of the list variable (do not include $)
.SS \f[V]bb_sort [-V LISTVAR] ITEM ...\f[R]
.PP
Sorts the items of a list in lexicographic ascending order
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[V]ITEM\f[R]: a list item
.SS \f[V]bb_sortdesc [-V LISTVAR] ITEM ...\f[R]
.PP
Sorts the items of a list in lexicographic descending order
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[V]ITEM\f[R]: a list item
.SS \f[V]bb_sortnums [-V LISTVAR] ITEM ...\f[R]
.PP
Sorts the items of a list in numerical ascending order
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[V]ITEM\f[R]: a list item
.SS \f[V]bb_sortnumsdesc [-V LISTVAR] ITEM ...\f[R]
.PP
Sorts the items of a list in numerical descending order
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[V]ITEM\f[R]: a list item
.SS \f[V]bb_sorthuman [-V LISTVAR] ITEM ...\f[R]
.PP
Sorts the items of a list in human-readable ascending order
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[V]ITEM\f[R]: a list item
.PP
\f[B]Notes:\f[R]
.PP
Human readable, e.g., 1K, 2M, 3G
.SS \f[V]bb_sorthumandesc [-V LISTVAR] ITEM ...\f[R]
.PP
Sorts the items of a list in human-readable descending order
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[V]ITEM\f[R]: a list item
.PP
\f[B]Notes:\f[R]
.PP
Human readable, e.g., 1K, 2M, 3G
.SS \f[V]bb_uniq [-V LISTVAR] ITEM ...\f[R]
.PP
Filters an unsorted list to include only unique items
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[V]ITEM\f[R]: a list item
.SS \f[V]bb_uniqsorted [-V LISTVAR] ITEM ...\f[R]
.PP
Filters an sorted list to include only unique items
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[V]ITEM\f[R]: a list item
.PP
\f[B]Notes:\f[R]
.PP
Faster than uniq, but requires the list to be pre-sorted
.SS \f[V]bb_islist LISTVAR\f[R]
.PP
Checks if the variable with the given name is a list with >1 element
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: name of a variable
.PP
\f[B]Notes:\f[R]
.PP
This will return false if the variable is declared as a list but only
has 1 element.
In that case, you can treat the variable as a scalar anyway.
.SS \f[V]bb_rename ITEM ... -- NAME ...\f[R]
.PP
Assigns new variable names to items
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]ITEM\f[R]: a list item
.IP \[bu] 2
\f[V]NAME\f[R]: a variable name
.PP
\f[B]Example:\f[R]
.IP
.nf
\f[C]
func() {
  bb_rename \[dq]$\[at]\[dq] -- first second
  echo \[dq]The first argument is $first\[dq]
  echo \[dq]The second argument is $second\[dq]
}
\f[R]
.fi
.SS \f[V]bb_unpack LISTVAR NAME ...\f[R]
.PP
Unpacks list items into named variables
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: name of the list variable (do not include $)
.IP \[bu] 2
\f[V]NAME\f[R]: a variable name to hold a list element
.SS \f[V]bb_map LISTVAR FUNCTION\f[R]
.PP
Maps a function over a list, modifying it in place
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: name of the list variable (do not include $)
.IP \[bu] 2
\f[V]FUNCTION\f[R]: a function or command to map a list element to a new
value
.SH Package util/math
.PP
Routines for common math operations
.SS \f[V]bb_sum [-v VAR] NUM ...\f[R]
.PP
Returns the sum of the given numbers
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]NUM\f[R]: a valid number
.SS \f[V]bb_min [-v VAR] NUM ...\f[R]
.PP
Returns the minimum of the given numbers
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]NUM\f[R]: a valid number
.SS \f[V]bb_max [-v VAR] NUM ...\f[R]
.PP
Returns the maximum of the given numbers
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]NUM\f[R]: a valid number
.SS \f[V]bb_abs [-v VAR] NUM\f[R]
.PP
Returns the absolute value of a given number
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]NUM\f[R]: a valid number
.SS \f[V]bb_isint NUM ...\f[R]
.PP
Checks if all the given numbers are valid integers
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]NUM\f[R]: a number to check
.PP
\f[B]Returns:\f[R] 0 if all arguments are integers, 1 otherwise
.SS \f[V]bb_hex2dec [-V LISTVAR] NUM ...\f[R]
.PP
Converts numbers from hexademical (base 16) to decimal (base 10)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[V]NUM\f[R]: a number to convert
.PP
\f[B]Returns:\f[R] 1 if any number is invalid hexadecimal, 0 otherwise
.SS \f[V]bb_dec2hex [-V LISTVAR] NUM ...\f[R]
.PP
Converts numbers from decimal (base 10) to hexademical (base 16)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[V]NUM\f[R]: a number to convert
.PP
\f[B]Returns:\f[R] 1 if any number is invalid decimal, 0 otherwise
.SS \f[V]bb_oct2dec [-V LISTVAR] NUM ...\f[R]
.PP
Converts numbers from octal (base 8) to decimal (base 10)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[V]NUM\f[R]: a number to convert
.PP
\f[B]Returns:\f[R] 1 if any number is invalid octal, 0 otherwise
.SS \f[V]bb_dec2oct [-V LISTVAR] NUM ...\f[R]
.PP
Converts numbers from decimal (base 10) to octal (base 8)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[V]NUM\f[R]: a number to convert
.PP
\f[B]Returns:\f[R] 1 if any number is invalid decimal, 0 otherwise
.SH Package util/prof
.PP
Routines for runtime profiling of bash scripts
.SS \f[V]bb_startprof LOGFILE\f[R]
.PP
Starts runtime profiling
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]LOGFILE\f[R]: (optional) file use to log profiling data Default:
TMPDIR/bbprof.PID.out
.PP
\f[B]Notes:\f[R]
.PP
Use the bbprof-read utility script to parse and analyze profile data
.SS \f[V]bb_stopprof\f[R]
.PP
Stops runtime profiling
.SH Package util/rand
.PP
Routines for generating random sequences
.SS \f[V]bb_randint [-v VAR] MAX [MIN]\f[R]
.PP
Returns a random non-negative integer between MIN and MAX
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]MAX\f[R]: the largest possible returned value
.IP \[bu] 2
\f[V]MIN\f[R]: the smallest possible returned value (defaults to zero)
.SS \f[V]bb_randstr [-v VAR] LENGTH [CHARSET]\f[R]
.PP
Returns a random string of the given length
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]LENGTH\f[R]: length of the returned string
.IP \[bu] 2
\f[V]CHARSET\f[R]: string with all possible characters to use (defaults
to all alphanumeric characters)
.SS \f[V]bb_loadworddict [FILENAME]\f[R]
.PP
Loads a dictionary of words
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]FILENAME\f[R]: file containing words, one per line
.PP
\f[B]Notes:\f[R]
.PP
The dictionary file should contain one word per line
.SS \f[V]bb_randwords [-v VAR] COUNT [SEP]\f[R]
.PP
Returns a string containing non-repeated random words from a loaded word
dictionary
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]COUNT\f[R]: number of returned words
.IP \[bu] 2
\f[V]SEP\f[R]: separator to use between words (default is space)
.PP
\f[B]Notes:\f[R]
.PP
You must load a word dictionary with bb_loadworddict before using this
.SH Package util/string
.PP
Routines for common string operations
.SS \f[V]bb_lstrip [-v VAR] TEXT\f[R]
.PP
Strips leading (left) whitespace from text
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]TEXT\f[R]: text to strip whitespace from
.SS \f[V]bb_rstrip [-v VAR] TEXT\f[R]
.PP
Strips trailing (right) whitespace from text
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]TEXT\f[R]: text to strip whitespace from
.SS \f[V]bb_strip [-v VAR] TEXT\f[R]
.PP
Strips leading and trailing whitespace from text
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]TEXT\f[R]: text to strip whitespace from
.SS \f[V]bb_ord [-v VAR] CHAR\f[R]
.PP
Converts character to its ASCII decimal code
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]CHAR\f[R]: a single character
.SS \f[V]bb_chr [-v VAR] CODE\f[R]
.PP
Converts ASCII decimal code to character
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]CODE\f[R]: an integer ASCII character code
.SS \f[V]bb_snake2camel [-v VAR] TEXT\f[R]
.PP
Converts text from snake to camel case
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]TEXT\f[R]: text in snake case
.PP
\f[B]Notes:\f[R]
.PP
Leading underscores are preserved
.SS \f[V]bb_camel2snake [-v VAR] TEXT\f[R]
.PP
Converts text from camel to snake case
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]TEXT\f[R]: text in camel case
.SS \f[V]bb_titlecase [-v VAR] TEXT\f[R]
.PP
Converts text into title case (every word capitalized)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]TEXT\f[R]: text to transform
.PP
\f[B]Notes:\f[R]
.PP
This does not check the content of the words itself and may not respect
grammatical rules, e.g.\ \[lq]And\[rq] will be capitalized
.SS \f[V]bb_sentcase [-v VAR] TEXT\f[R]
.PP
Converts text into sentence case (every first word capitalized)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]TEXT\f[R]: text to transform
.SS \f[V]bb_urlencode [-v VAR] TEXT\f[R]
.PP
Performs URL (percent) encoding on the given string
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]TEXT\f[R]: text to be encoded
.SS \f[V]bb_urldecode [-v VAR] TEXT\f[R]
.PP
Decodes URL-encoded text
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]TEXT\f[R]: text to be decoded
.PP
\f[B]Returns:\f[R] 1 if the input URL encoding is malformed, 0 otherwise
.SS \f[V]bb_repeatstr [-v VAR] NUM TEXT\f[R]
.PP
Repeat TEXT NUM times
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]NUM\f[R]: repeat this many times (integer)
.IP \[bu] 2
\f[V]TEXT\f[R]: text to repeat
.SS \f[V]bb_centerstr [-v VAR] WIDTH TEXT [FILL]\f[R]
.PP
Pad and center TEXT with FILL character to have WIDTH width
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]WIDTH\f[R]: width of the padded string result
.IP \[bu] 2
\f[V]TEXT\f[R]: text to display
.IP \[bu] 2
\f[V]FILL\f[R]: character used for padding (if not given, uses space)
.PP
\f[B]Notes:\f[R]
.PP
If the text cannot be perfectly centered, it will be pushed closer to
the left side.
TEXT may contain color codes.
.SS \f[V]bb_cmpversion VER1 VER2 [DELIM]\f[R]
.PP
Checks if VER1 is greater than or equal to VER2
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VER1\f[R]: a version string (containing only numerals and
delimeters)
.IP \[bu] 2
\f[V]VER2\f[R]: another version string, usually a reference point
.IP \[bu] 2
\f[V]DELIM\f[R]: character(s) to delimit fields in the version string
(default: .-_)
.PP
\f[B]Returns:\f[R] 0 if VER1 greater or equal to VER2, 1 otherwise
.PP
\f[B]Notes:\f[R]
.PP
Numeric comparison is used, so alphabetical characters are not supported
.SH Package util/time
.PP
Routines for common time and date operations
.PP
\f[B]Example:\f[R]
.IP
.nf
\f[C]
bb_timefmt \[dq]%F %T\[dq] # e.g., 2022-11-20 16:53:30
bb_timefmt \[dq]%F %T\[dq] $(bb_now +1h) # one hour from now
bb_timefmt \[dq]%F %T\[dq] $(bb_now \[ha]h)  # end of the hour
bb_timefmt \[dq]%F %T\[dq] $(bb_now +1d) # one day from now
bb_timefmt \[dq]%F %T\[dq] $(bb_now \[ha]d)  # end of the day
bb_timefmt \[dq]%F %T\[dq] $(bb_now +2w \[ha]d) # after two weeks, at end of day
\f[R]
.fi
.SS \f[V]bb_now [-v VAR] [OFFSET ...]\f[R]
.PP
Returns a timestamp relative to the current time (in seconds after
epoch)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]OFFSET\f[R]: {+,-}N{s,m,h,d,w}[\[ha]] where N is an integer
.PP
\f[B]Returns:\f[R] 1 if any offset is invalid, 0 otherwise
.PP
\f[B]Notes:\f[R]
.PP
s: seconds m: minutes h: hours d: days w: weeks Optional: trailing \[ha]
rounds up; \[ha]d is short for +0d\[ha]
.SS \f[V]bb_timefmt [-v VAR] FORMAT [TIMESTAMP]\f[R]
.PP
Formats a timestamp into a desired date format
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[V]FORMAT\f[R]: date format string, refer to man strftime
.IP \[bu] 2
\f[V]TIMESTAMP\f[R]: epoch time, defaults to current time (now)
.SS \f[V]bb_timedeltafmt [-v VAR] FORMAT TIME1 [TIME2]\f[R]
.PP
Formats a time delta into a desired format
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[V]VAR\f[R]:
.IP \[bu] 2
\f[V]FORMAT\f[R]:
.IP \[bu] 2
\f[V]TIME1\f[R]: if TIME1 not specified, this is interpreted as a
duration in seconds
.IP \[bu] 2
\f[V]TIME2\f[R]: if specified, TIME1 is the end timestamp and TIME2 is
the start timestamp
.PP
\f[B]Notes:\f[R]
.PP
Capital letters D, H, M, S represent the partial value Lowercase letters
d, h, m, s represent the total value
.PP
\f[B]Example:\f[R]
.IP
.nf
\f[C]
bb_now -v start
sleep 120s
bb_now -v end
bb_timedeltafmt -v elapsed \[dq]%H:%M:%S\[dq] end start
bb_timedeltafmt -v total_seconds \[dq]%s\[dq] end start
echo \[dq]elapsed time $elapsed, $total_seconds total seconds\[dq]
# above should print \[dq]elapsed time 00:02:00, 120 total seconds\[dq]
\f[R]
.fi
.SH AUTHORS
github.com/tomocafe.
