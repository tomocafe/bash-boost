.\" Automatically generated by Pandoc 2.5
.\"
.TH "BASH\-BOOST" "1" "January 16, 2022" "" ""
.hy
.SH Package cli/arg
.PP
Routines for parsing command line arguments
.PP
\f[B]Example:\f[R]
.IP
.nf
\f[C]
bb_setprog \[dq]myprogram\[dq]
bb_addopt f:foo \[dq]Number of foos (default: 2)\[dq] 2
bb_addflag b:bar \[dq]Bar flag\[dq]
bb_setpositional \[dq]THINGS\[dq] \[dq]Things to process\[dq]
bb_parseargs \[dq]$\[at]\[dq]
set \-\- \[dq]${BB_POSARGS[\[at]]}\[dq] # $\[at] now only contains the positional arguments
bb_checkopt bar && echo \[dq]You gave the bar flag!\[dq]
bb_getopt \-v fooval foo
[[ $fooval \-gt 0 ]] || bb_errusage \[dq]foo val must be greater than 0\[dq]
echo \[dq]You set foo to $fooval\[dq]
for arg in \[dq]$\[at]\[dq]; do
  echo \[dq]You have item $arg\[dq]
done
\f[R]
.fi
.SS \f[C]bb_addopt [SHORTNAME:]LONGNAME [DESCRIPTION] [DEFAULT]\f[R]
.PP
Adds a command line option to be parsed
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]SHORTNAME\f[R]: optional single character, e.g.\ \[lq]f\[rq] for an
\-f FOO option
.IP \[bu] 2
\f[C]LONGNAME\f[R]: required long name, e.g.\ \[lq]foo\[rq] for a
\[en]foo FOO option
.IP \[bu] 2
\f[C]DESCRIPTION\f[R]: description of the option used in help
.IP \[bu] 2
\f[C]DEFAULT\f[R]: the default value of the option if not given in the
command line
.PP
\f[B]Notes:\f[R]
.PP
\-h and \[en]help are reserved for automatically\-generated command
usage and help
.SS \f[C]bb_addflag [SHORTNAME:]LONGNAME [DESCRIPTION]\f[R]
.PP
Adds a command line flag to be parsed
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]SHORTNAME\f[R]: optional single character, e.g.\ \[lq]f\[rq] for an
\-f flag
.IP \[bu] 2
\f[C]LONGNAME\f[R]: required long name, e.g.\ \[lq]foo\[rq] for a
\[en]foo flag
.IP \[bu] 2
\f[C]DESCRIPTION\f[R]: description of the option used in help
.PP
\f[B]Notes:\f[R]
.PP
\-h and \[en]help are reserved for automatically\-generated command
usage and help
.SS \f[C]bb_argusage\f[R]
.PP
Print the command line usage string
.SS \f[C]bb_arghelp\f[R]
.PP
Print the command line help
.PP
\f[B]Notes:\f[R]
.PP
Includes the usage string and a list of flags and options with their
descriptions.
.SS \f[C]bb_errusage MESSAGE [RETURNVAL]\f[R]
.PP
Issues an error message, prints the command usage, and exits the shell
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]MESSAGE\f[R]: error message to be printed
.IP \[bu] 2
\f[C]RETURNVAL\f[R]: return code to exit with (defaults to 1)
.SS \f[C]bb_isflag LONGNAME\f[R]
.PP
Check if LONGNAME is a registered flag (not an option)
.PP
\f[B]Returns:\f[R] 0 if LONGNAME is a flag, 1 otherwise (i.e.\ it is an
option)
.SS \f[C]bb_setprog PROGNAME\f[R]
.PP
Sets the name of the program for printing usage and help
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]PROGNAME\f[R]: name of the program
.SS \f[C]bb_setpositional NAME DESCRIPTION\f[R]
.PP
Sets the name and description of the positional arguments
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]NAME\f[R]: one\-word name of the positional arguments
(auto\-capitalized)
.IP \[bu] 2
\f[C]DESCRIPTION\f[R]: description of the positionals used in help
.SS \f[C]bb_parseargs ARGS\f[R]
.PP
Parses command line arguments after registering valid flags and options
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]ARGS\f[R]: the list of command line arguments, usually
\[lq]$\[at]\[rq]
.PP
\f[B]Notes:\f[R]
.PP
Check flags with checkopt LONGNAME Get option setting values with getopt
LONGNAME Get positional arguments with ${BB_POSARGS[\[at]]} array If the
last argument is a single dash (\-), read remaining arguments from stdin
.SS \f[C]bb_getopt [\-v VAR] LONGNAME\f[R]
.PP
Gets the value of option named LONGNAME
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]LONGNAME\f[R]: long name of the option
.SS \f[C]bb_checkopt LONGNAME\f[R]
.PP
Returns the value of flag named LONGNAME
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LONGNAME\f[R]: long name of the flag
.PP
\f[B]Returns:\f[R] the flag value
.SS \f[C]bb_argclear\f[R]
.PP
Clears all registered argument parsing settings
.PP
\f[B]Notes:\f[R]
.PP
Only one \[lq]command\[rq] can be registered for parsing at once so this
can be used to clear the state of a previous command and start a new one
.SH Package cli/color
.PP
Routines for printing text in color using ANSI escape codes
.SS \f[C]bb_colorize COLORSTR TEXT\f[R]
.PP
Prints the given text in color if outputting to a terminal
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]COLORSTR\f[R]: FGCOLOR[\f[I]on\f[R][BGCOLOR]] (e.g.\ red,
bright_red, white_on_blue)
.IP \[bu] 2
\f[C]TEXT\f[R]: text to be printed in color
.PP
\f[B]Returns:\f[R] 0 if text was printed in color, 1 otherwise
.PP
\f[B]Notes:\f[R]
.PP
Supported colors: \- black \- red \- green \- yellow \- blue \- magenta
\- cyan \- bright_gray (dark_white) \- gray (bright_black) \- bright_red
\- bright_green \- bright_yellow \- bright_blue \- bright_magenta \-
bright_cyan \- white (bright_white)
.PP
This does not print a new line at the end of TEXT
.SS \f[C]bb_rawcolor COLORSTR TEXT\f[R]
.PP
Like colorize but always uses prints in color
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]COLORSTR\f[R]: FGCOLOR[\f[I]on\f[R][BGCOLOR]] (e.g.\ red,
bright_red, white_on_blue)
.IP \[bu] 2
\f[C]TEXT\f[R]: text to be printed in color
.PP
\f[B]Notes:\f[R]
.PP
Use this instead of colorize if you need to still print in color even if
not connected to a terminal, e.g.\ when saving the output to a variable.
See colorize for supported colors
.SS \f[C]bb_colorstrip TEXT\f[R]
.PP
Strips ANSI color codes from text colorized by colorize (or rawcolor)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]TEXT\f[R]: text possibly with color escape codes to be removed
.PP
\f[B]Notes:\f[R]
.PP
This is only guaranteed to work on text generated by colorize and
variants, not for any generic string with ANSI escape codes.
.SH Package cli/input
.PP
Routines for handling user input
.SS \f[C]bb_getinput VAR PROMPT\f[R]
.PP
Prompts for input and saves the response to VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store response into (do not include $)
.IP \[bu] 2
\f[C]PROMPT\f[R]: text displayed to the user
.SS \f[C]bb_yn PROMPT\f[R]
.PP
Prompts user to confirm an action by pressing Y
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]PROMPT\f[R]: text displayed to the user
.PP
\f[B]Returns:\f[R] 0 if yes, 1 otherwise
.PP
\f[B]Notes:\f[R]
.PP
If you want the user to type \[lq]yes\[rq], use getinput and check their
response
.SS \f[C]bb_pause PROMPT\f[R]
.PP
Prompts user to press a key to continue
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]PROMPT\f[R]: text displayed to the user Default: Press any key to
continue
.SH Package cli/msg
.PP
Messaging routines
.SS \f[C]bb_info MESSAGE\f[R]
.PP
Prints an informational message to stderr
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]MESSAGE\f[R]: message to be printed
.SS \f[C]bb_warn MESSAGE\f[R]
.PP
Prints a warning message to stderr
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]MESSAGE\f[R]: message to be printed
.SS \f[C]bb_error MESSAGE\f[R]
.PP
Prints an error message to stderr
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]MESSAGE\f[R]: message to be printed
.SS \f[C]bb_fatal MESSAGE [RETURNCODE]\f[R]
.PP
Prints an error message to stderr and then exits the shell
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]MESSAGE\f[R]: message to be printed
.IP \[bu] 2
\f[C]RETURNCODE\f[R]: return code to exit with (defaults to 1)
.SS \f[C]bb_expect VAL1 VAL2 [MESSAGE] [RETURNCODE]\f[R]
.PP
Issues a fatal error if two given values are not equal
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAL1\f[R]: value to check
.IP \[bu] 2
\f[C]VAL2\f[R]: value to check against (golden answer)
.IP \[bu] 2
\f[C]MESSAGE\f[R]: optional prefix to the error message
.IP \[bu] 2
\f[C]RETURNCODE\f[R]: return code to exit with (defaults to 1)
.SS \f[C]bb_expectsubstr VAL1 VAL2 [MESSAGE] [RETURNCODE]\f[R]
.PP
Issues a fatal error if a given substring is not found in some given
text
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAL1\f[R]: text to check
.IP \[bu] 2
\f[C]VAL2\f[R]: substring to be found
.IP \[bu] 2
\f[C]MESSAGE\f[R]: optional prefix to the error message
.IP \[bu] 2
\f[C]RETURNCODE\f[R]: return code to exit with (defaults to 1)
.SS \f[C]bb_loglevel [LEVEL]\f[R]
.PP
Sets the current log level
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LEVEL\f[R]: integer representing the current log verbosity level
(default: 0)
.SS \f[C]bb_setloglevelname LEVEL NAME\f[R]
.PP
Assigns a name to the given log level
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LEVEL\f[R]: integer representing the current log verbosity level
.IP \[bu] 2
\f[C]NAME\f[R]: name to be assigned
.SS \f[C]bb_log LEVEL MESSAGE\f[R]
.PP
Issues a message at a certain log level
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LEVEL\f[R]: minimum logging level required to print the message
.IP \[bu] 2
\f[C]MESSAGE\f[R]: message to be printed
.PP
\f[B]Notes:\f[R]
.PP
Set BB_LOG_TIMEFMT to a valid time format string to override the default
.SH Package core
.PP
Core routines
.SS \f[C]bb_load PKG ...\f[R]
.PP
Loads a module or package
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]PKG\f[R]: either a package (e.g.\ cli/arg) or a whole module
(e.g.\ cli)
.PP
\f[B]Notes:\f[R]
.PP
Each package only loads once; if you happen to load one twice, the
second time has no effect
.SS \f[C]bb_isloaded PKG\f[R]
.PP
Checks if a package is loaded already
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]PKG\f[R]: package name in internal format, e.g.\ bb_cli_arg
.PP
\f[B]Returns:\f[R] 0 if loaded, 1 otherwise
.SS \f[C]bb_debug TEXT\f[R]
.PP
Log text when debugging is enabled
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]TEXT\f[R]: message to be logged in debug mode
.PP
\f[B]Notes:\f[R]
.PP
Set environment variable BB_DEBUG to enable debug mode
.SS \f[C]bb_issourced\f[R]
.PP
Check if the script is being sourced
.PP
\f[B]Returns:\f[R] 0 if sourced, 1 otherwise
.SS \f[C]bb_stacktrace\f[R]
.PP
Print a stack trace to stderr
.SS \f[C]bb_cleanup\f[R]
.PP
Clears all functions and variables defined by bash\-boost
.SH Package interactive/cmd
.PP
Miscellaneous interactive commands
.SS \f[C]bb_mcd DIR\f[R]
.PP
Make director(ies) and change directory to the last one
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]DIR\f[R]: usually a single directory to be made, but all arguments
are passed to mkdir and the last argument is then passed to cd if mkdir
is successful
.SS \f[C]bb_up [DIR]\f[R]
.PP
Change directory up
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]DIR\f[R]: go to this directory, otherwise defaults to ..
if no DIR specified
.PP
\f[B]Notes:\f[R]
.PP
Most useful with the associated command completion.
After pressing TAB, the current working directory is populated, and with
each further TAB, a directory is removed, moving you up the directory
stack.
Once you see the upward directory you want to go to, hit ENTER
.SS \f[C]bb_forkterm [ARGS ...]\f[R]
.PP
Spawn a new terminal instance inheriting from this shell\[cq]s
environment
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]ARGS\f[R]: arguments to be appended to the terminal launch command
.PP
\f[B]Notes:\f[R]
.PP
Uses the BB_TERMINAL or TERMINAL environment variable as the command to
launch the new terminal instance.
Sets the BB_FORKDIR variable for the spawned shell to read.
In your shell init file, you can detect when this variable is set and
change to this directory, if desired.
.SH Package interactive/prompt
.PP
Routines for managing a dynamic shell prompt
.SS \f[C]bb_loadprompt\f[R]
.PP
Activates the registered dynamic prompt
.SS \f[C]bb_unloadprompt\f[R]
.PP
Deactivates the registered dynamic prompt
.PP
\f[B]Notes:\f[R]
.PP
This will restore the prompt to the state it was in when loadprompt was
called
.SS \f[C]bb_setpromptleft FUNCTION ...\f[R]
.PP
Sets the left prompt to the output of the list of given functions
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]FUNCTION\f[R]: a function whose stdout output will be added to the
prompt
.PP
\f[B]Notes:\f[R]
.PP
The prompt areas are as follows:
.IP
.nf
\f[C]
  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
  | left prompt               right prompt |
  | nextline prompt                        |
  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\f[R]
.fi
.SS \f[C]bb_setpromptright FUNCTION ...\f[R]
.PP
Sets the right prompt to the output of the list of given functions
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]FUNCTION\f[R]: a function whose stdout output will be added to the
prompt
.SS \f[C]bb_setpromptnextline FUNCTION ...\f[R]
.PP
Sets the next line prompt to the output of the list of given functions
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]FUNCTION\f[R]: a function whose stdout output will be added to the
prompt
.SS \f[C]bb_setwintitle FUNCTION\f[R]
.PP
Sets the window title to the output of the list of given functions
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]FUNCTION\f[R]: a function whose stdout output will used as the
window title
.SS \f[C]bb_settabtitle FUNCTION\f[R]
.PP
Sets the tab title to the output of the list of given functions
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]FUNCTION\f[R]: a function whose stdout output will used as the tab
title
.PP
\f[B]Notes:\f[R]
.PP
Not all terminals support this
.SS \f[C]bb_promptcolor COLORSTR TEXT\f[R]
.PP
Prints text in color, for use specifically in prompts
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]COLORSTR\f[R]: valid color string, see bb_colorize
.IP \[bu] 2
\f[C]TEXT\f[R]: text to be printed in color
.PP
\f[B]Notes:\f[R]
.PP
This is like colorize but adds [ and ] around non\-printing characters
which are needed specifically in prompts
.SH Package util/env
.PP
Routines for checking and setting environment variables
.SS \f[C]bb_checkset VAR\f[R]
.PP
Check if an environment variable is set or empty
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: name of the variable to check (don\[cq]t include $)
.PP
\f[B]Returns:\f[R] 1 if unset, 2 if set but empty, 0 otherwise
.SS \f[C]bb_iscmd COMMAND\f[R]
.PP
Check if COMMAND is a valid command
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]COMMAND\f[R]: name of command to check (e.g., ls)
.PP
\f[B]Notes:\f[R]
.PP
This could be an executable in your PATH, or a function or bash builtin
.SS \f[C]bb_inpath VAR ITEM ...\f[R]
.PP
Checks if items are in the colon\-separated path variable VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[C]ITEM\f[R]: items to find in the path variable
.PP
\f[B]Returns:\f[R] 0 if all items are in the path, 1 otherwise
.SS \f[C]bb_prependpath VAR ITEM ...\f[R]
.PP
Prepends items to the colon\-separated path variable VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[C]ITEM\f[R]: items to add to the path variable
.SS \f[C]bb_appendpath VAR ITEM ...\f[R]
.PP
Appends items to the colon\-separated path variable VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[C]ITEM\f[R]: items to add to the path variable
.SS \f[C]bb_prependpathuniq VAR ITEM ...\f[R]
.PP
Prepends unique items to the colon\-separated path variable VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[C]ITEM\f[R]: items to add to the path variable
.PP
\f[B]Notes:\f[R]
.PP
If an item is already in the path, it is not added twice
.SS \f[C]bb_appendpathuniq VAR ITEM ...\f[R]
.PP
Appends unique items to the colon\-separated path variable VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[C]ITEM\f[R]: items to add to the path variable
.PP
\f[B]Notes:\f[R]
.PP
If an item is already in the path, it is not added twice
.SS \f[C]bb_removefrompath VAR ITEM ...\f[R]
.PP
Removes items from the colon\-separated path variable VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[C]ITEM\f[R]: items to remove from the path variable
.PP
\f[B]Returns:\f[R] 0 if any item was removed, 1 otherwise
.SS \f[C]bb_swapinpath VAR ITEM1 ITEM2\f[R]
.PP
Swaps two items in a colon\-separated path variable VAR
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[C]ITEM1\f[R]: first item to swap
.IP \[bu] 2
\f[C]ITEM2\f[R]: second item to swap
.PP
\f[B]Returns:\f[R] 0 if swap is successful, 1 if either ITEM1 or ITEM2
was not in the path 2 if insufficient arguments were supplied (less than
3) 3 for internal error
.SS \f[C]bb_printpath VAR [SEP]\f[R]
.PP
Prints a path variable separated by SEP, one item per line
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: path variable, e.g.\ PATH (do not use $)
.IP \[bu] 2
\f[C]SEP\f[R]: separator character, defaults to :
.SH Package util/file
.PP
Routines for common file operations
.SS \f[C]bb_canonicalize [\-v VAR] PATH\f[R]
.PP
Resolves .
and ..
in a given absolute path
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]PATH\f[R]: an absolute path
.PP
\f[B]Returns:\f[R] 1 if PATH is invalid, 0 otherwise
.SS \f[C]bb_abspath [\-v VAR] TARGET [FROM]\f[R]
.PP
Returns the absolute path from a relative one
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]TARGET\f[R]: target relative path (can be file or directory)
.IP \[bu] 2
\f[C]FROM\f[R]: the absolute directory path from which the absolute path
is formed (Defaults to $PWD)
.SS \f[C]bb_relpath [\-v VAR] TARGET [FROM]\f[R]
.PP
Returns the relative path from a directory to the target
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]TARGET\f[R]: target absolute path (can be file or directory)
.IP \[bu] 2
\f[C]FROM\f[R]: the absolute directory path from which the relative path
is formed (Defaults to $PWD)
.PP
\f[B]Returns:\f[R] 1 if either TARGET or FROM is invalid, 0 otherwise
.SS \f[C]bb_countlines FILENAME ...\f[R]
.PP
Counts the number of lines in a list of files
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]FILENAME\f[R]: a valid filename
.PP
\f[B]Returns:\f[R] 1 if any of the filenames are invalid, 0 otherwise
.SS \f[C]bb_countmatches PATTERN FILENAME ...\f[R]
.PP
Counts the number of matching lines in a list of files
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]PATTERN\f[R]: a valid bash regular expression
.IP \[bu] 2
\f[C]FILENAME\f[R]: a valid filename
.PP
\f[B]Returns:\f[R] 1 if any of the filenames are invalid, 0 otherwise
.SS \f[C]bb_extpush EXT FILENAME ...\f[R]
.PP
Adds the file extension EXT to all given files
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]EXT\f[R]: the file extension
.IP \[bu] 2
\f[C]FILENAME\f[R]: a valid filename
.SS \f[C]bb_extpop FILENAME ...\f[R]
.PP
Removes the last file extension from the given files
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]FILENAME\f[R]: a valid filename
.SS \f[C]bb_hardcopy FILENAME ...\f[R]
.PP
Replaces symbolic links with deep copies
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]FILENAME\f[R]: a valid symbolic link
.SH Package util/kwargs
.PP
Routines for parsing keyword arg strings
.PP
\f[B]Example:\f[R]
.IP
.nf
\f[C]
talk() {
  bb_kwparse opts \[dq]$\[at]\[dq]
  set \-\- \[dq]${BB_OTHERARGS[\[at]]}\[dq] # $\[at] now only contains non\-kwargs
  local verb=\[dq]${opts[verb]:\-have}\[dq]
  local item
  for item in \[dq]$\[at]\[dq]; do
    echo \[dq]You $verb $item\[dq]
  done
}
talk eggs milk bread
talk verb=ate eggs milk bread
\f[R]
.fi
.SS \f[C]bb_kwparse MAP KEY=VAL ... ARGS ...\f[R]
.PP
Parses a list of KEY=VAL pairs and stores them into a dictionary
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]MAP\f[R]: name of an associative array to be created
.IP \[bu] 2
\f[C]KEY=VAL\f[R]: a key\-value pair separated by =
.IP \[bu] 2
\f[C]ARGS\f[R]: other arguments not in KEY=VAL format are ignored
.PP
\f[B]Notes:\f[R]
.PP
Get non\-keyword arguments with ${BB_OTHERARGS[\[at]]}
.SH Package util/list
.PP
Routines for common list operations
.SS \f[C]bb_join [\-v VAR] SEP ITEM ...\f[R]
.PP
Joins the list of items into a string with the given separator
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]SEP\f[R]: separator
.IP \[bu] 2
\f[C]ITEM\f[R]: a list item
.SS \f[C]bb_split [\-V LISTVAR] SEP STR\f[R]
.PP
Splits a string into a list based on a separator
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[C]SEP\f[R]: separator
.IP \[bu] 2
\f[C]STR\f[R]: string to split
.SS \f[C]bb_inlist TARGET LIST ...\f[R]
.PP
Checks if a target item exists in a given list
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]TARGET\f[R]: the search target
.IP \[bu] 2
\f[C]LIST\f[R]: a list item
.PP
\f[B]Returns:\f[R] 0 if found, 1 otherwise
.SS \f[C]bb_push LISTVAR ITEM ...\f[R]
.PP
Pushes an item to a list (stack)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: name of the list variable (do not include $)
.IP \[bu] 2
\f[C]ITEM\f[R]: item to push
.SS \f[C]bb_pop LISTVAR\f[R]
.PP
Pops an item from a list (stack)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: name of the list variable (do not include $)
.SS \f[C]bb_unshift LISTVAR ITEM ...\f[R]
.PP
Unshifts an item from a list (stack)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: name of the list variable (do not include $)
.IP \[bu] 2
\f[C]ITEM\f[R]: item to unshift
.SS \f[C]bb_shift LISTVAR\f[R]
.PP
Shifts an item from a list (stack)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: name of the list variable (do not include $)
.SS \f[C]bb_sort [\-V LISTVAR] ITEM ...\f[R]
.PP
Sorts the items of a list in lexicographic ascending order
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[C]ITEM\f[R]: a list item
.SS \f[C]bb_sortdesc [\-V LISTVAR] ITEM ...\f[R]
.PP
Sorts the items of a list in lexicographic descending order
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[C]ITEM\f[R]: a list item
.SS \f[C]bb_sortnums [\-V LISTVAR] ITEM ...\f[R]
.PP
Sorts the items of a list in numerical ascending order
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[C]ITEM\f[R]: a list item
.SS \f[C]bb_sortnumsdesc [\-V LISTVAR] ITEM ...\f[R]
.PP
Sorts the items of a list in numerical descending order
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[C]ITEM\f[R]: a list item
.SS \f[C]bb_sorthuman [\-V LISTVAR] ITEM ...\f[R]
.PP
Sorts the items of a list in human\-readable ascending order
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[C]ITEM\f[R]: a list item
.PP
\f[B]Notes:\f[R]
.PP
Human readable, e.g., 1K, 2M, 3G
.SS \f[C]bb_sorthumandesc [\-V LISTVAR] ITEM ...\f[R]
.PP
Sorts the items of a list in human\-readable descending order
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[C]ITEM\f[R]: a list item
.PP
\f[B]Notes:\f[R]
.PP
Human readable, e.g., 1K, 2M, 3G
.SS \f[C]bb_uniq [\-V LISTVAR] ITEM ...\f[R]
.PP
Filters an unsorted list to include only unique items
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[C]ITEM\f[R]: a list item
.SS \f[C]bb_uniqsorted [\-V LISTVAR] ITEM ...\f[R]
.PP
Filters an sorted list to include only unique items
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[C]ITEM\f[R]: a list item
.PP
\f[B]Notes:\f[R]
.PP
Faster than uniq, but requires the list to be pre\-sorted
.SH Package util/math
.PP
Routines for common math operations
.SS \f[C]bb_sum [\-v VAR] NUM ...\f[R]
.PP
Returns the sum of the given numbers
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]NUM\f[R]: a valid number
.SS \f[C]bb_min [\-v VAR] NUM ...\f[R]
.PP
Returns the minimum of the given numbers
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]NUM\f[R]: a valid number
.SS \f[C]bb_max [\-v VAR] NUM ...\f[R]
.PP
Returns the maximum of the given numbers
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]NUM\f[R]: a valid number
.SS \f[C]bb_abs [\-v VAR] NUM\f[R]
.PP
Returns the absolute value of a given number
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]NUM\f[R]: a valid number
.SS \f[C]bb_isint NUM ...\f[R]
.PP
Checks if all the given numbers are valid integers
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]NUM\f[R]: a number to check
.PP
\f[B]Returns:\f[R] 0 if all arguments are integers, 1 otherwise
.SS \f[C]bb_hex2dec [\-V LISTVAR] NUM ...\f[R]
.PP
Converts numbers from hexademical (base 16) to decimal (base 10)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[C]NUM\f[R]: a number to convert
.PP
\f[B]Returns:\f[R] 1 if any number is invalid hexadecimal, 0 otherwise
.SS \f[C]bb_dec2hex [\-V LISTVAR] NUM ...\f[R]
.PP
Converts numbers from decimal (base 10) to hexademical (base 16)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[C]NUM\f[R]: a number to convert
.PP
\f[B]Returns:\f[R] 1 if any number is invalid decimal, 0 otherwise
.SS \f[C]bb_oct2dec [\-V LISTVAR] NUM ...\f[R]
.PP
Converts numbers from octal (base 8) to decimal (base 10)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[C]NUM\f[R]: a number to convert
.PP
\f[B]Returns:\f[R] 1 if any number is invalid octal, 0 otherwise
.SS \f[C]bb_dec2oct [\-V LISTVAR] NUM ...\f[R]
.PP
Converts numbers from decimal (base 10) to octal (base 8)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LISTVAR\f[R]: list variable to store result (if not given, prints
to stdout)
.IP \[bu] 2
\f[C]NUM\f[R]: a number to convert
.PP
\f[B]Returns:\f[R] 1 if any number is invalid decimal, 0 otherwise
.SH Package util/prof
.PP
Routines for runtime profiling of bash scripts
.SS \f[C]bb_startprof LOGFILE\f[R]
.PP
Starts runtime profiling
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]LOGFILE\f[R]: (optional) file use to log profiling data Default:
TMPDIR/bbprof.PID.out
.PP
\f[B]Notes:\f[R]
.PP
Use the bbprof\-read utility script to parse and analyze profile data
.SS \f[C]bb_stopprof\f[R]
.PP
Stops runtime profiling
.SH Package util/string
.PP
Routines for common string operations
.SS \f[C]bb_lstrip [\-v VAR] TEXT\f[R]
.PP
Strips leading (left) whitespace from text
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]TEXT\f[R]: text to strip whitespace from
.SS \f[C]bb_rstrip [\-v VAR] TEXT\f[R]
.PP
Strips trailing (right) whitespace from text
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]TEXT\f[R]: text to strip whitespace from
.SS \f[C]bb_strip [\-v VAR] TEXT\f[R]
.PP
Strips leading and trailing whitespace from text
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]TEXT\f[R]: text to strip whitespace from
.SS \f[C]bb_ord [\-v VAR] CHAR\f[R]
.PP
Converts character to its ASCII decimal code
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]CHAR\f[R]: a single character
.SS \f[C]bb_chr [\-v VAR] CODE\f[R]
.PP
Converts ASCII decimal code to character
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]CODE\f[R]: an integer ASCII character code
.SS \f[C]bb_snake2camel [\-v VAR] TEXT\f[R]
.PP
Converts text from snake to camel case
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]TEXT\f[R]: text in snake case
.PP
\f[B]Notes:\f[R]
.PP
Leading underscores are preserved
.SS \f[C]bb_camel2snake [\-v VAR] TEXT\f[R]
.PP
Converts text from camel to snake case
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]TEXT\f[R]: text in camel case
.SS \f[C]bb_titlecase [\-v VAR] TEXT\f[R]
.PP
Converts text into title case (every word capitalized)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]TEXT\f[R]: text to transform
.PP
\f[B]Notes:\f[R]
.PP
This does not check the content of the words itself and may not respect
grammatical rules, e.g.\ \[lq]And\[rq] will be capitalized
.SS \f[C]bb_sentcase [\-v VAR] TEXT\f[R]
.PP
Converts text into sentence case (every first word capitalized)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]TEXT\f[R]: text to transform
.SS \f[C]bb_urlencode [\-v VAR] TEXT\f[R]
.PP
Performs URL (percent) encoding on the given string
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]TEXT\f[R]: text to be encoded
.SS \f[C]bb_urldecode [\-v VAR] TEXT\f[R]
.PP
Decodes URL\-encoded text
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]TEXT\f[R]: text to be decoded
.PP
\f[B]Returns:\f[R] 1 if the input URL encoding is malformed, 0 otherwise
.SS \f[C]bb_repeatstr [\-v VAR] NUM TEXT\f[R]
.PP
Repeat TEXT NUM times
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]NUM\f[R]: repeat this many times (integer)
.IP \[bu] 2
\f[C]TEXT\f[R]: text to repeat
.SH Package util/time
.PP
Routines for common time and date operations
.SS \f[C]bb_now [\-v VAR] [OFFSET ...]\f[R]
.PP
Returns a timestamp relative to the current time (in seconds after
epoch)
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]OFFSET\f[R]: {+,\-}N{s,m,h,d,w} where N is an integer
.PP
\f[B]Returns:\f[R] 1 if any offset is invalid, 0 otherwise
.PP
\f[B]Notes:\f[R]
.PP
s: seconds m: minutes h: hours d: days w: weeks
.SS \f[C]bb_timefmt [\-v VAR] FORMAT [TIMESTAMP]\f[R]
.PP
Formats a timestamp into a desired date format
.PP
\f[B]Arguments:\f[R]
.IP \[bu] 2
\f[C]VAR\f[R]: variable to store result (if not given, prints to stdout)
.IP \[bu] 2
\f[C]FORMAT\f[R]: date format string, refer to man strftime
.IP \[bu] 2
\f[C]TIMESTAMP\f[R]: epoch time, defaults to current time (now)
.SH AUTHORS
github.com/tomocafe.
